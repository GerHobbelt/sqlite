# 2018 February 15
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library. The focus
# of this file is the sqlite3_replication_xxx() APIs.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
ifcapable !replication {finish_test; return}
set testprefix replication

# Configure SQLite with the test replication implementation and create
# a test database in WAL mode.
#
proc reset_replication {} {
  catch {db close}
  catch {db2 close}
  forcedelete test2.db
  forcedelete test2.db-wal
  sqlite3_shutdown
  sqlite3_config_test_replication 0
  sqlite3_config_test_replication 1
  reset_db
  execsql {
    PRAGMA journal_mode = WAL;
  }
}

#-------------------------------------------------------------------------
# The following block of tests - wal-1.* - focus on testing the
# implementation of the sqlite3_replication_mode() interface.

# Test that an error is returned if the database is not in WAL mode.
#
do_test 1.0 {
  execsql {
    PRAGMA journal_mode = DELETE;
  }
  list [catch {sqlite3_replication_mode db main} msg] $msg
} {1 SQLITE_ERROR}

# Test that an error is returned if the given schema name does not exist.
#
do_test 1.1 {
  list [catch {sqlite3_replication_mode db garbage} msg] $msg
} {1 SQLITE_ERROR}

# Test that by default no write-ahead log replication is setup.
#
do_test 1.2 {
  reset_replication
  sqlite3_replication_mode db main
} {SQLITE_REPLICATION_NONE}

#-------------------------------------------------------------------------
# The following block of tests - wal-2.* - focus on testing the
# implementation of the sqlite3_replication_leader() interface.

# Test that an error is returned if the database is not in WAL mode.
#
do_test 2.0 {
  execsql {
    PRAGMA journal_mode = DELETE;
  }
  list [catch {sqlite3_replication_leader db main} msg] $msg
} {1 SQLITE_ERROR}

# Test that an error is returned if the given schema name is invalid.
#
do_test 2.1 {
  reset_replication
  list [catch {sqlite3_replication_leader db garbage} msg] $msg
} {1 SQLITE_ERROR}

# Test that trying to enable leader replication twice for the same
# database results in an error.
#
do_test 2.2 {
  reset_replication
  sqlite3_replication_leader db main
  list [catch {sqlite3_replication_leader db main} msg] $msg
} {1 SQLITE_ERROR}

# Test that an error is returned if the current mode is follower.
#
do_test 2.3 {
  reset_replication
  sqlite3_replication_follower db main
  list [catch {sqlite3_replication_leader db main} msg] $msg
} {1 SQLITE_ERROR}

# Test that the replication mode value is set to
# SQLITE_REPLICATION_LEADER after a successful call.
#
do_test 2.4 {
  reset_replication
  sqlite3_replication_leader db main
  sqlite3_replication_mode db main
} {SQLITE_REPLICATION_LEADER}

# Test that a connection in leader replication mode works transparently from the
# user point of view, and that regular write queries can be performed.
#
do_test 2.5 {
  reset_replication
  sqlite3_replication_leader db main
  execsql {
    CREATE TABLE test (n INT);
    INSERT INTO test(n) VALUES(1);
    SELECT n FROM test;
  }
} {1}

# Test that a connection in leader replication mode works transparently from the
# user point of view, and that regular rollbacks can be performed.
#
do_test 2.6 {
  reset_replication
  sqlite3_replication_leader db main
  execsql {
    CREATE TABLE test (n INT);
    BEGIN;
    INSERT INTO test(n) VALUES(1);
    ROLLBACK;
    SELECT n FROM test;
  }
} {}

# Test that checkpoint-on-close is disabled for leader connections.
#
do_test 2.7 {
  reset_replication
  sqlite3_replication_leader db main
  execsql {
    CREATE TABLE test (n INT);
    INSERT INTO test(n) VALUES(1);
    SELECT n FROM test;
  }
  db close
  file exists test.db-wal
} {1}

#-------------------------------------------------------------------------
# The following block of tests - wal-3.* - focus on testing the
# implementation of the sqlite3_replication_follower() interface.

# Test that an error is returned if the given schema name is invalid.
#
do_test 3.0 {
  reset_replication
  list [catch {sqlite3_replication_follower db garbage} msg] $msg
} {1 SQLITE_ERROR}

# Test that trying to enable follower replication twice for the same
# database results in an error.
#
do_test 3.1 {
  reset_replication
  sqlite3_replication_follower db main
  list [catch {sqlite3_replication_follower db main} msg] $msg
} {1 SQLITE_ERROR}

# Test that an error is returned if the current mode is leader.
#
do_test 3.2 {
  reset_replication
  sqlite3_replication_leader db main
  list [catch {sqlite3_replication_follower db main} msg] $msg
} {1 SQLITE_ERROR}

# Test that the replication mode value is set to
# SQLITE_REPLICATION_FOLLOWER after a successful call.
#
do_test 3.3 {
  reset_replication
  sqlite3_replication_follower db main
  sqlite3_replication_mode db main
} {SQLITE_REPLICATION_FOLLOWER}

# Test that an error is returned when trying to backup a database in follower
# replication mode.
#
do_test 3.4 {
  reset_replication
  sqlite3_replication_follower db main
  delete_file test2.db
  sqlite3 db2 test2.db
  list [catch {sqlite3_backup B db2 main db main} msg] $msg
} {1 {sqlite3_backup_init() failed}}

# Test that an error is returned when trying to perform a query on a database
# in follower replication mode.
#
do_test 3.5 {
  reset_replication
  sqlite3_replication_follower db main
  list [catch {db eval {SELECT 1}} msg] $msg
} {1 {database is in follower replication mode: main}}

#-------------------------------------------------------------------------
# The following block of tests - wal-4.* - focus on testing the
# implementation of the sqlite3_replication_none() interface.

# Test that an error is returned if the given schema name is invalid.
#
do_test 4.0 {
  reset_replication
  list [catch {sqlite3_replication_none db garbage} msg] $msg
} {1 SQLITE_ERROR}

# Test that an error is returned if the current mode is neither leader
# or follower.
#
do_test 4.1 {
  reset_replication
  list [catch {sqlite3_replication_none db main} msg] $msg
} {1 SQLITE_ERROR}

# Test that a connection can be set back to no replication after it
# was set to leader replication.
#
do_test 4.2 {
  reset_replication
  sqlite3_replication_leader db main
  sqlite3_replication_none db main
  sqlite3_replication_mode db main
} {SQLITE_REPLICATION_NONE}

# Test that a connection can be set back to no replication after it
# was set to follower replication.
#
do_test 4.3 {
  reset_replication
  sqlite3_replication_follower db main
  sqlite3_replication_none db main
  sqlite3_replication_mode db main
} {SQLITE_REPLICATION_NONE}

# Test that a connection that is set back to no replication after
# follower replication can perform queries again.
#
do_test 4.4 {
  reset_replication
  sqlite3_replication_follower db main
  sqlite3_replication_none db main
  execsql {SELECT 1}
} {1}

#-------------------------------------------------------------------------
# The following block of tests - wal-5.* - focus on testing the
# implementation of the sqlite3_replication_{begin,frames,undo,end}()
# interfaces, by running them both on a leader and an follower
# connection, using the test replication implementation.

# Test that replicated transactions work transparently from the leader
# connection user's point of view.
#
do_test 5.0 {
  reset_replication
  sqlite3 db2 ./test2.db
  execsql {
    PRAGMA journal_mode = WAL;
  } db2
  sqlite3_replication_leader db main
  sqlite3_replication_follower db2 main
  execsql {
    CREATE TABLE test (n INT);
    INSERT INTO test(n) VALUES(1);
    SELECT n FROM test;
  }
} {1}

# Test that the content of the WAL is replicated to the follower
# connection.
#
do_test 5.1 {
  reset_replication
  sqlite3 db2 ./test2.db
  execsql {
    PRAGMA journal_mode = WAL;
  } db2
  sqlite3_replication_leader db main
  sqlite3_replication_follower db2 main
  execsql {
    CREATE TABLE test (n INT);
    INSERT INTO test(n) VALUES(1);
  }
  db close
  db2 close

  # checkpoint-on-close is disabled for both leader and follower
  # connections
  file exists test.db-wal
  file exists test2.db-wal

  set size1 [file size test.db-wal]
  set size2 [file size test2.db-wal]

  expr {$size1 > 0 && $size1 == $size2 }
} {1}

# Test that opening and querying a replicated database works normally.
#
do_test 5.2 {
  reset_replication
  sqlite3 db2 ./test2.db
  execsql {
    PRAGMA journal_mode = WAL;
  } db2
  sqlite3_replication_leader db main
  sqlite3_replication_follower db2 main
  execsql {
    CREATE TABLE test (n INT);
    INSERT INTO test(n) VALUES(1);
  }
  sqlite3_replication_none db2 main
  execsql {
    SELECT n FROM TEST;
  } db2
} {1}

# Test that rolling back a transaction reverts the changes in the
# follower database as well.
#
do_test 5.3 {
  reset_replication
  sqlite3 db2 ./test2.db
  execsql {
    PRAGMA journal_mode = WAL;
  } db2
  sqlite3_replication_leader db main
  sqlite3_replication_follower db2 main
  execsql {
    CREATE TABLE test (n INT);
    BEGIN;
    INSERT INTO test(n) VALUES(1);
    ROLLBACK;
  }
  sqlite3_replication_none db2 main
  execsql {
    SELECT n FROM TEST;
  } db2
} {}

# Test that checkpointing leader or follower databases works.
#
do_test 5.4 {
  reset_replication
  execsql {
    CREATE TABLE test (n INT);
  }
  sqlite3_replication_follower db main
  sqlite3_replication_checkpoint db main

  file size ./test.db-wal
} {0}

# Test that if the xBegin or xFrame hook returns a replication error,
# then the transaction fails.
#
foreach { i method error } {
1 xBegin  NOT_LEADER
2 xBegin  LEADERSHIP_LOST
3 xFrames NOT_LEADER
4 xFrames LEADERSHIP_LOST
} {
  do_test 5.5.$i {
    catch {db close}
    sqlite3_shutdown
    sqlite3_config_test_replication 0
    sqlite3_config_test_replication 1 $method $error
    reset_db
    execsql {
      PRAGMA journal_mode = WAL;
    }
    sqlite3_replication_leader db main
    list [catch {db eval {CREATE TABLE test (n INT)}} msg] $msg
  } {1 {disk I/O error}}
}

# Test that if the pager fails to begin a WAL write transaction,
# the xAbort hook is fired.
#
do_test 5.6 {
  reset_replication
  execsql {
    CREATE TABLE test (n INT);
  }
  sqlite3_replication_leader db main
  sqlite3 db2 ./test.db
  db2 eval {
    BEGIN;
    INSERT INTO test VALUES(1);
  }

  # Trying to start a write transaction now fails with
  # SQLITE_BUSY, and should trigger the xAbort hook.
  catch {db eval {
    BEGIN;
    INSERT INTO test VALUES(2);
  }}
  db eval { ROLLBACK }
  db2 eval { COMMIT; }

  # Re-trying the failed insert succeeds, as the xAbort
  # hook has reset the state of the global replication.
  execsql {
    BEGIN;
    INSERT INTO test VALUES(2);
    COMMIT;
  }
} {}

# Test that if the xUndo hook returns a replication error, the
# rollback still succeeds.
#
foreach { i method error } {
1 xUndo  NOT_LEADER
2 xUndo  LEADERSHIP_LOST
} {
  do_test 5.7.$i {
    catch {db close}
    sqlite3_shutdown
    sqlite3_config_test_replication 0
    sqlite3_config_test_replication 1 $method $error
    reset_db
    execsql {
      PRAGMA journal_mode = WAL;
    }
    sqlite3_replication_leader db main
    execsql {
      BEGIN;
      CREATE TABLE test (n INT);
      ROLLBACK;
    }
  } {}
}

# Test that read transactions don't trigger any replication hook.
#
do_test 5.7 {
  catch {db close}
  sqlite3_shutdown
  sqlite3_config_test_replication 0
  sqlite3_config_test_replication 1 xBegin NOT_LEADER
  reset_db
  execsql {
    PRAGMA journal_mode = WAL;
    CREATE TABLE test (n INT);
    INSERT INTO test(n) VALUES(1);
  }
  sqlite3_replication_leader db main
  execsql {
    SELECT n FROM test;
  }
} {1}

# Test that the WAL write lock is released if the xBegin replication
# hook fails.
#
do_test 5.8 {
  catch {db close}
  sqlite3_shutdown
  sqlite3_config_test_replication 0
  sqlite3_config_test_replication 1 xBegin LEADERSHIP_LOST 1
  reset_db
  execsql {
    PRAGMA journal_mode = WAL;
  }
  sqlite3_replication_leader db main
  catch {db eval {
    BEGIN;
    CREATE TABLE test (n INT);
  }}
  db eval {BEGIN; CREATE TABLE test (n INT); COMMIT;}
} {}

# Reset the replication configuration for subsequent tests.
catch {db close}
catch {db2 close}
sqlite3_shutdown
sqlite3_config_test_replication 0
sqlite3_initialize
autoinstall_test_functions

finish_test
